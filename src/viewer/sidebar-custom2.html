<link rel="stylesheet" href="https://unpkg.com/vue-material@beta/dist/vue-material.min.css">
<link rel="stylesheet" href="https://unpkg.com/vue-material@1.0.0-beta-7/dist/theme/default-dark.css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:400,500,700,400italic|Material+Icons">
<style>
	.custom-menu-toggle {
		position: absolute;
		float: left;
		margin: 8px 8px;
		background: none;
		width: 2.5em;
		height: 2.5em;
		z-index: 1900;
		cursor: pointer;
	}
</style>

<div id="vue-menu-control">
	<img src="http://localhost/potree/libs/potree/resources/icons/menu_button.svg" class="custom-menu-toggle" v-on:click="onToggleMenu" v-if="menuButtonVisible">
</div>




<script>
    /*
	$.getScript( "vue.min.js", function( data, textStatus, jqxhr ) {
		$.getScript( "vue-material.min.js", function( data, textStatus, jqxhr ) {
			initCustomSidebar = (viewer) => {
				Vue.use(VueMaterial.default)

				new Vue({
					el: '#vue-menu-control',
					data: {
						menuOpen: false,			// Menu is closed by default
						menuButtonVisible: true,		// When template is loaded we don't want the menu button to be visible
													// until Vue is loaded and ready. Upon initialisation set the menu button visible
						topPosition: 'md-top-left',
						subMenuOpen:false
					},
					methods: {
						onToggleMenu:function() {
							console.log('onToggleMenu()');
							let renderArea = $('#potree_render_area');
							let isVisible = renderArea.css('left') !== '0px';

							console.log('menuOpen = '+ this.menuOpen);
							if (this.menuOpen) {
								renderArea.css('left', '0px');
							} else {
								renderArea.css('left', '300px');
							}

							this.menuOpen = !this.menuOpen;
						},
						onOpenSubMenu:function(){
							this.subMenuOpen = !this.subMenuOpen;
						}
					
					}
				});
				

				//var pcMaterialSize = viewer.scene.pointclouds[0].material.size;
				var pointcloud = viewer.scene.pointclouds[0];
				new Vue({
					el: '#vue-menu',
					data: {
						menuVisible:true,
						pointBudget: 	viewer.getPointBudget(),
						pcMaterialSize: pointcloud.material.size,
						fov: 			viewer.getFOV(),
						background: 	viewer.getBackground(),
						shape: 			'' + pointcloud.material.shape,
						adaptivePointsChecked: (pointcloud.material.pointSizeType == Potree.PointSizeType.ADAPTIVE),
					},
					methods: {
						toggleMenu () {
        this.menuVisible = !this.menuVisible
      },
						onPointBudgetChange:function(event) {
							this.pointBudget = event.target.value;
							viewer.setPointBudget(this.pointBudget);
						},
						onPointSizeChange: function (event) {
							this.pcMaterialSize = event.target.value;
							pointcloud.material.size = parseFloat(this.pcMaterialSize);
						},
						onFovChange:function(event) {
							this.fov = event.target.value;
							viewer.setFOV(this.fov);
						},
						onEarthControlsClick:function(event) {
							viewer.setNavigationMode(Potree.EarthControls);
						},
						onFirstPersonControlsClick:function(event) {
							viewer.setNavigationMode(Potree.FirstPersonControls);
						},
						onOrbitControlsClick:function(event) {
							viewer.setNavigationMode(Potree.OrbitControls);
						},
						onFitToScreenClick:function(event) {
							viewer.fitToScreen();
						},
						onPerspectiveCameraClick:function(event) {
							viewer.switchCameraMode(Potree.CameraMode.PERSPECTIVE);
						},
						onOrthographicCameraClick:function(event) {
							viewer.switchCameraMode(Potree.CameraMode.ORTHOGRAPHIC)
						}
					},
					watch: {
						background: {
							handler(val) {
								console.log('background changed = ' + val);
								viewer.setBackground(val);
							}
						},
						shape: {
							handler(val) {
								console.log('shape changed = ' + val);
								pointcloud.material.shape = parseInt(val);
								//pcMaterial.pointSizeType = Potree.PointSizeType[ui.item.value];
							}
						},
						adaptivePointsChecked: {
							handler(val) {
								console.log('adaptivePointsChecked = ' + val);
								if(val) {
									pointcloud.material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
								} else {
									pointcloud.material.pointSizeType = Potree.PointSizeType.FIXED;
								}
							}
						}
					},
					computed: {
						shapeName: function() {
							if(this.shape == 0) { return 'square';}
							if(this.shape == 1) { return 'round';}
							if(this.shape == 2) { return 'parabloid';}
						},
						pointTypeName:function() {
							return (this.adaptivePointsChecked) ? 'Adaptive' : 'Fixed';
						},
						pointBudgetDisplay:function() {
							return (this.pointBudget/1000000).toFixed(1);
						}
					}
				});
			}

			initCustomSidebar(window.viewer);
		});
    
    	
    });
	*/
</script>